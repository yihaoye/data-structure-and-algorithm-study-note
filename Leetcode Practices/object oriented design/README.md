## OOD 学习资源
### 针对面试
* [Grok Object Oriented Design Tutorial](./grok%20object%20oriented%20design%20interview)
* 面向对象设计专题班（文泰来 / 九章算法），目录如下（[链接](https://www.youtube.com/watch?v=oaUVVBOhyJw) 仅能免费看第一部分）
  * 面向对象设计入门 Introduction to Object Oriented Design（高频 OOD 面试题 - 电梯设计 Elevator Design）
      * OOD 面试应对方法
        * SOLID 设计原则（以下链接皆为示例代码）
          * [S 单一功能原则](./SOLID/SingleResponsibility.java):    对象或类应该仅具有一种单一功能。
          * [O 开闭原则](./SOLID/OpenClose.java):       对象或实体应该对扩展开放，对修改封闭。
          * [L 里氏替换原则](./SOLID/LiskovSubstitution.java):    任何一个子类或派生类应该可以替换它们的基类或父类（参考契约式设计）（通常与 I 接口隔离原则互为表里）。
          * [I 接口隔离原则](./SOLID/InterfaceSeggregation.java):    多个特定客户端接口要好于一个宽泛用途的接口（不应该强迫一个类实现它用不上的接口）（通常与 L 里氏替换原则互为表里）。
          * [D 依赖反转原则](./SOLID/DependencyInversion.java):    抽象不应该依赖于具体实现，具体实现应该依赖于抽象。High level 实体不应该依赖于 Low level 实体。
        * 5C 解题法  
![](./5c.svg)  
      * 设计模式讲解 Design Pattern - Strategy
  * 管理类面向对象设计 OOD for Management System（停车场问题 Parking Lot）
  * 预定类面向对象设计 OOD for Reservation System（餐厅管理问题 Restaurant、酒店预订系统设计 Hotel Reservation）
  * 实物类面向对象设计 OOD for Real Life Object（Vending Machine 自动售货机、Coffee Maker 咖啡机、Kindle 设计）
      * 设计模式讲解 Design Pattern Factory
      * 设计模式讲解 Design Pattern: Adaptor
  * 游戏棋牌类面向对象设计 OOD for Games（Tictactoe、Chinese Chess、Black Jack）
* 其他面向对象设计原则
  * CARP（Composition/Aggregation Reuse Principle），设计者首先应当考虑复合/聚合，而不是继承。这个就是所谓的 Favor Composition over Inheritance，在实践中复合/聚合会带来比继承更大的利益，所以要优先考虑。
  * LoD or LKP（Law of Demeter or Least Knowlegde Principle），迪米特法则或最少知识原则，这个原则首次在 Demeter 系统中得到正式运用，所以定义为迪米特法则。即一个对象应当尽可能少的去了解其他对象。也就是又一个关于如何松耦合（Loosely-Coupled）的法则。
  * 61 条面向对象设计的经验原则（来源于《OOD启思录》，不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但应当把这些原则看成警告，若违背了其中的一条，警告就会响起。）
    1. 所有数据都应该隐藏在所在的类的内部。
    2. 类的使用者必须依赖类的共有接口，但类不能依赖它的使用者。
    3. 尽量减少类的协议中的消息。
    4. 实现所有类都理解的最基本公有接口（例如，拷贝操作 - 深拷贝和浅拷贝、相等性判断、正确输出内容、从ASCII描述解析等等）。
    5. 不要把实现细节(例如放置共用代码的私有函数)放到类的公有接口中。如果类的两个方法有一段公共代码，那么就可以创建一个防止这些公共代码的私有函数。
    6. 不要以用户无法使用或不感兴趣的东西扰乱类的公有接口。
    7. 类之间应该零耦合，或者只有导出耦合关系。也即，一个类要么同另一个类毫无关系，要么只使用另一个类的公有接口中的操作。 
    8. 类应该只表示一个关键抽象。包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包影响，则将对包中的所有类产生影响，而对其他的包不造成任何影响。
    9.  把相关的数据和行为集中放置。设计者应当留意那些通过get之类操作从别的对象中获取数据的对象。这种类型的行为暗示着这条经验原则被违反了。
    10. 把不相关的信息放在另一个类中(也即：互不沟通的行为)。朝着稳定的方向进行依赖。
    11. 确保你为之建模的抽象概念是类，而不只是对象扮演的角色。
    12. 在水平方向上尽可能统一地分布系统功能，也即：按照设计，顶层类应当统一地共享工作。
    13. 在你的系统中不要创建全能类/对象。对名字包含 Driver、Manager、System、Susystem 的类要特别多加小心。规划一个接口而不是实现一个接口。
    14. 对公共接口中定义了大量访问方法的类多加小心。大量访问方法意味着相关数据和行为没有集中存放。
    15. 对包含太多互不沟通的行为的类多加小心。这个问题的另一表现是在你的应用程序中的类的公有接口中创建了很多的get和set函数。
    16. 在由同用户界面交互的面向对象模型构成的应用程序中，模型不应该依赖于界面，界面则应当依赖于模型。
    17. 尽可能地按照现实世界建模(我们常常为了遵守系统功能分布原则、避免全能类原则以及集中放置相关数据和行为的原则而违背这条原则) 。
    18. 从你的设计中去除不需要的类。一般来说，我们会把这个类降级成一个属性。
    19. 去除系统外的类。系统外的类的特点是，抽象地看它们只往系统领域发送消息但并不接受系统领域内其他类发出的消息。
    20. 不要把操作变成类。质疑任何名字是动词或者派生自动词的类，特别是只有一个有意义行为的类。考虑一下那个有意义的行为是否应当迁移到已经存在或者尚未发现的某个类中。
    21. 我们在创建应用程序的分析模型时常常引入代理类。在设计阶段，我们常会发现很多代理没有用的，应当去除。
    22. 尽量减少类的协作者的数量。一个类用到的其他类的数目应当尽量少。
    23. 尽量减少类和协作者之间传递的消息的数量。
    24. 尽量减少类和协作者之间的协作量，也即：减少类和协作者之间传递的不同消息的数量。
    25. 尽量减少类的扇出，也即：减少类定义的消息数和发送的消息数的乘积。
    26. 如果类包含另一个类的对象，那么包含类应当给被包含的对象发送消息。也即：包含关系总是意味着使用关系。
    27. 类中定义的大多数方法都应当在大多数时间里使用大多数数据成员。
    28. 类包含的对象数目不应当超过开发者短期记忆的容量。这个数目常常是6。当类包含多于6个数据成员时，可以把逻辑相关的数据成员划分为一组，然后用一个新的包含类去包含这一组成员。
    29. 让系统功能在窄而深的继承体系中垂直分布。
    30. 在实现语义约束时，最好根据类定义来实现。这常常会导致类泛滥成灾，在这种情况下，约束应当在类的行为中实现，通常是在构造函数中实现，但不是必须如此。
    31. 在类的构造函数中实现语义约束时，把约束测试放在构造函数领域所允许的尽量深的包含层次中。
    32. 约束所依赖的语义信息如果经常改变，那么最好放在一个集中式的第3方对象中。
    33. 约束所依赖的语义信息如果很少改变，那么最好分布在约束所涉及的各个类中。
    34. 类必须知道它包含什么，但是不能知道谁包含它。
    35. 共享字面范围(也就是被同一个类所包含)的对象相互之间不应当有使用关系。
    36. 继承只应被用来为特化层次结构建模。
    37. 派生类必须知道基类，基类不应该知道关于它们的派生类的任何信息。
    38. 基类中的所有数据都应当是私有的，不要使用保护数据。类的设计者永远都不应该把类的使用者不需要的东西放在公有接口中。
    39. 在理论上，继承层次体系应当深一点，越深越好。
    40. 在实践中，继承层次体系的深度不应当超出一个普通人的短期记忆能力。一个广为接受的深度值是 6。
    41. 所有的抽象类都应当是基类。
    42. 所有的基类都应当是抽象类。
    43. 把数据、行为和/或接口的共性尽可能地放到继承层次体系的高端。
    44. 如果两个或更多个类共享公共数据(但没有公共行为)，那么应当把公共数据放在一个类中，每个共享这个数据的类都包含这个类。
    45. 如果两个或更多个类有共同的数据和行为(就是方法)，那么这些类的每一个都应当从一个表示了这些数据和方法的公共基类继承。
    46. 如果两个或更多个类共享公共接口(指的是消息，而不是方法)，那么只有他们需要被多态地使用时，他们才应当从一个公共基类继承。
    47. 对对象类型的显示的分情况分析一般是错误的。在大多数这样的情况下，设计者应当使用多态。
    48. 对属性值的显示的分情况分析常常是错误的。类应当解耦合成一个继承层次结构，每个属性值都被变换成一个派生类。
    49. 不要通过继承关系来为类的动态语义建模。试图用静态语义关系来为动态语义建模会导致在运行时切换类型。
    50. 不要把类的对象变成派生类。对任何只有一个实例的派生类都要多加小心。
    51. 如果你觉得需要在运行时刻创建新的类，那么退后一步以认清你要创建的是对象。现在，把这些对象概括成一个类。
    52. 在派生类中用空方法(也就是什么也不做的方法)来覆写基类中的方法应当是非法的。
    53. 不要把可选包含同对继承的需要相混淆。把可选包含建模成继承会带来泛滥成灾的类。
    54. 在创建继承层次时，试着创建可复用的框架，而不是可复用的组件。
    55. 如果你在设计中使用了多重继承，先假设你犯了错误。如果没犯错误，你需要设法证明。
    56. 只要在面向对象设计中用到了继承，问自己两个问题：(1)派生类是否是它继承的那个东西的一个特殊类型?(2)基类是不是派生类的一部分?
    57. 如果你在一个面向对象设计中发现了多重继承关系，确保没有哪个基类实际上是另一个基类的派生类。
    58. 在面向对象设计中如果你需要在包含关系和关联关系间作出选择，请选择包含关系。
    59. 不要把全局数据或全局函数用于类的对象的薄记工作。应当使用类变量或类方法。
    60. 面向对象设计者不应当让物理设计准则来破坏他们的逻辑设计。但是，在对逻辑设计作出决策的过程中我们经常用到物理设计准则。
    61. 不要绕开公共接口去修改对象的状态。
* 详细掌握 OOD 的基本方法与步骤
  1. 类的认定 - OOD 中关于类的认定与 OOA 中关于对象的认定有着密切关系。但是 OOD 中对类的认定，不能像 OOA 中那样以准确反映问题空间为衡量准则，更多的要考虑通过对类以及类层次结构的认定，寻找解空间的基本结构，并为实现提供有效的支持。以下这些准则有助于更好的认定、定义类与方法：
     1. 对于问题空间中自然出现的实体，用类进行模型化；
     2. 将方法设计成单用途的；
     3. 如果需要对已有方法进行扩展，就设计一个新的方法；
     4. 避免冗长的方法；
     5. 把那些为多个方法或某个子类所需要的数据，存贮存实例变量中；
     6. 为类库设计，不要只为你自己或者你目前的应用设计
  2. 类的设计 - 在任何的面向对象应用中，类实例是系统的主要部分，而且如果采用纯面向对象的方法，那么整个系统就是由类实例组成的。因此，每个独立的类的设计对整个应用系统都有影响。在进行类的设计时，应考虑下面一些因素：
     1. 类的公共接口的单独成员应该是类的操作符；
     2. 类 A 的实例不应该直接发送消息给类 B 的成分；
     3. 操作符是公共的当且仅当类实例的用户可用；
     4. 属于类的每个操作符要么访问要么修改类的某个数据；
     5. 类必须尽可能少地依赖其他类；
     6. 两个类之间的互相作用应该是显式的；
     7. 采用子类继承超类的公共接口，开发子类成员为超类的特化；
     8. 继承结构的根类应该是目标概念的抽象模型。
  3. 类层次结构的组织 - OOD 中类层次结构的组织与 OOA 采用的策略是相似的，但在涉及递增开发时将有不同。支持重用是 OOD 的主要任务，继承机制支持两种层次的重用。在高层设计阶段，继承性可用作泛化特化关系的建模工具。使用继承机制促进开发出有意义的高级抽象，进而有助于重用。继承关系的重用性使得设计者能够在抽象中识别一般性，并从一般产生高级抽象。通过识别这种一般性，并把它从的较高的抽象中移出来，它就在当前或今后的设计中变成可重用。在详细设计阶段，继承性支持已有类作为新定义类的重用基础，可以把已有的部分代码复制到新子类中并修改，以适应其新的目的。继承性在已有类和新的类之间建立了一种依赖关系，子类的新代码不引起旧代码失效，继承的代码被自动地包含在新定义中，并作为新类的定义被编译。对已有的类的任何修改都被归并到下次编译的新类中。
  4. 类模块之间的接口技术 - 类之间的接口是中的一个关键，接口的方法大致有以下几类：
     1. 通过继承机制实现类之间的接口 - 第一种方法是可定义两层或多层：描述接口的通用类以及提供各种实现的子类（例如以列表作为通用类，以堆栈，队列等作为列表的实现），从而实现同一接口，不同实现的接口方法。第二种方法使用继承机制实现类模块接口对称目的：采用几种接口到基本模块中，通过继承的正交性与输出机制来实现此方法。通用类不作输出，而多个子类执行不同的输出。例如银行的账目作为通用类，而由不同的用户来实现对它的查询。
     2. 使类实例具有人工智能的状态机和主动数据结构 - 在定义类实现抽象数据类型及数据抽象时，将这些抽象设置于“主动”方式。也就是说，类实例不仅作为信息的被动集合，而且可看作具有内部状态及局部存储的状态机。这为类之间接口提供了有用的方法。
  5. 对类库和应用构架的支持 - OOD 的最终目标是把方法和实例变量放在类库中抽象层次尽可能高的类中，一个方法在类库的类层次结构中的层次越高，能够共享这个方法的子类就越多，以这种方式进行设计，就使重用达到了最大的可能限度。由于类库的目标是支持重用，所以纳入类库的类层次结构必须仔细加以推敲。这里主要指从有利于重用的角度来设计。尽管这方面还没有形式化的方法论，因而也没有完全自动化的工具，但可从下面 3 个方面着手：
     1. 改善标准的协议，在面对象系统中，消息传递是对象之间通信的唯一方式，从通信的角度来看，消息的内容便是对象之间的通信协议。应提高协议的标准化程度，如：为相应的方法设计一致的接口；限制消息中的参数个数；简化方法的功能等。
     2. 提高类的抽象程度，对于一个健全的类库来说，它的层次结构在进行若干层次的子类设计后，应当是深而窄的。这是因为，如果类层次结构中的层次较多。而每一层上的类少，就表明对象的共有特性经过了比较细致的分层次抽象，使用类的特殊性逐渐增强，因而能够提供较多的、在特定应用范畴内可普遍适用的类。
     3. 认定和培育构架，类库中的类就象一般建筑预制件，可以复杂到整个单元居室，也可以简单到梁柱，规格比较标准，容易被独立使用。但需要应用开发人员自己根据应用特征进行组装，因此类库本身并不是重用的基本单位。相对地，构架则是以构件之间有密切的联系为特征，面向特定的应用范畴，以整个构架而不是其中的单个构件来体现它的能量，因此构架本身是重用的基本单位，一旦与应用特征相符，就可以整体被重用。所以，构架是 OOD 是理想的目标。
* [Top 10 OOD Interview questions](https://hackernoon.com/the-top-10-object-oriented-design-interview-questions-developers-should-know-c7fc2e13ce39)  
* [educative.io](https://www.educative.io/courses/grokking-the-object-oriented-design-interview)  
  
### 其他
* [Chaklader/Object-Oriented-Design](https://github.com/Chaklader/Object-Oriented-Design)  
  
