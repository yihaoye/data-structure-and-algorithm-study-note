枚举（Enumerate）是基于已有知识来猜测答案的一种问题求解策略。  
枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。  
  
穷举法又称穷举搜索法，是一种在问题域的解空间中对所有可能的解穷举搜索，并根据条件选择最优解的方法的总称。  
  
数学上也把穷举法称为枚举法，就是在一个由有限个元素构成的集合中，把所有元素一一枚举研究的方法。  
  
穷举是用计算机求解问题最常用的方法之一，常用来解决那些通过公式推导、规则演绎的方法不能解决的问题。  
  
## 要点
* 确定问题的解（或状态）的定义、解空间的范围以及正确解的判定条件 - 可能的情况是什么？要枚举哪些要素？建立简洁的数学模型（包括一组变量、以及这些变量需要满足的条件）。
* 减少枚举的空间 - 枚举的范围限定，不是所有的内容都需要枚举的（否则会带来不必要的时间开销）。
* 根据解空间的特点来选择搜索策略（比如选择合适的枚举顺序） - 根据题目判断，比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。  
    
### 解空间
解空间就是全部可能的候选解的一个约束范围，确定问题的解就在这个约束范围内，将搜索策略应用到这个约束范围就可以找到问题的解。要确定解空间，首先要定义问题的解并建立解的数据模型。如果解的数据模型选择错误或不合适，则会导致解空间结构繁杂、范围难以界定，甚至无法设计穷举算法。  
穷举解空间的策略就是搜索算法的设计策略，根据问题的类型，解空间的结构可能是线性表、集合、树或者图，对于不同类型的解空间，需要设计与之相适应的穷举搜索算法。简单的问题可以用通用的搜索算法，比如线性搜索算法用于对线性解空间的搜索，广度优先和深度优先的递归搜索算法适用于树型解空间或更复杂的图型解空间。  
  
盲目搜索和启发式搜索：  
对于线性问题的盲目搜索，就是把线性表中的所有算法按照一定的顺序遍历一遍，对于复杂问题的盲目搜索，常用广度优先搜索和深度优先搜索这两种盲目搜索算法。如果搜索能够智能化一点，利用搜索过程中出现的额外信息直接跳过一些状态，避免盲目的、机械式的搜索，就可以加快搜索算法的收敛，这就是启发性搜索。启发性搜索需要一些额外信息和操作来“启发”搜索算法，根据这些信息的不同，启发的方式也不同。  
  
### 剪枝策略  
对解空间穷举搜索时，如果有一些状态节点可以根据问题提供的信息明确地被判定为不可能演化出最优解，也就是说，**从此节点开始遍历得到的子树，可能存在正确的解，但是肯定不是最优解，就可以跳过此状态节点的遍历，这将极大地提高算法的执行效率，这就是剪枝策略**，应用剪枝策略的难点在于如何找到一个评价方法（估值函数）对状态节点进行评估。  
*特定的评价方法都附着在特定的搜索算法中，比如博弈树算法中常用的极大极小值算法和“α-β”算法，都伴随着相应的剪枝算法。*  
  
剪枝不是启发性搜索。剪枝的原理是在结果已经搜索出来或部分搜索出来（比如树的根节点已经搜索出来了，但是叶子节点还没有搜索出来）的情况下，根据最优解的判断条件，确定这个方向上不可能存在最优解，从而放弃对这个方向的继续搜索。而启发性搜索通常是根据启发函数给出的评估值，在结果出来之前就朝着最可能出现最优解的方向搜索。它们的差异点在于是根据结果进行判断还是根据启发函数的评估值进行判断。  
  
## 例题
Q：一个数组中的数互不相同，求其中和为 0 的数对的个数？  
  
解题思路  
枚举两个数的代码很容易就可以写出来  
```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < n; ++j)
    if (a[i] + a[j] == 0) ++ans;
```  
来看看枚举的范围如何优化。原问题的答案由两部分构成：两个数相等的情况和不相等的情况。相等的情况不可能因为数组中的数互不相同，所以不可能出现两个 0，且题目寻求的是数对的个数所以单个 0 不能算进计数。至于不相等的情况，由于题中没要求数对是有序的，答案就是有序的情况的两倍（考虑如果 (a, b) 是答案，那么 (b, a) 也是答案）。对于这种情况，只需统计人为要求有顺序之后的答案，最后再乘上 2 就好了。  
  
不妨要求第一个数要出现在靠前的位置。代码如下：  
```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < i; ++j)
    if (a[i] + a[j] == 0) ++ans;
```  
不难发现这里已经减少了 j 的枚举范围，减少了这段代码的时间开销。  
然而这并不是最优的结果。  
  
两个数是否都一定要枚举出来呢？枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。  
```cpp
// 要求 a 数组中的数的绝对值都小于 MAXN（注意 MAXN 不是数组长度，而是 a 数组中的元素的绝对值的最大值 -- 最小负值的反数或最大正值，由此保证 met[MAXN - |a[i]|] 或 met[MAXN + |a[i]|] 不会造成数组越界）
bool met[MAXN * 2];
// 初始化 met 数组为 0；
memset(met, 0, sizeof(met));
for (int i = 0; i < n; ++i) {
  if (met[MAXN - a[i]]) ++ans; // 若 met[MAXN - a[i]] 等于 1，说明 a[i] 的相反值 a[j] 在前面已被遭遇（j < i）并执行了下一行的 met[MAXN + a[j]] = 1，此时说明一对相反数被发现因此执行 ++ans。a[j]、a[i] 均会执行一次下面的 met[MAXN + a[x]] = 1 但只有第一次有实际作用，同理第一次 if (met[MAXN - a[j]]) ++ans 必然不符合条件将被跳过。若 a[j] 的相反数 a[i] 直到最后都没有出现，则什么事都不会发生因为程序仅仅只执行了一次 met[MAXN + a[j]] = 1 而且因为 met[MAXN + a[j]] 是唯一的所以不会影响任何其他数组里的元素（因为其他元素的值皆不等于 a[j] 或其相反数 -- a[j] 或 a[i] 均只会最多出现一次因为输入数组设定元素不重复）
  met[MAXN + a[i]] = 1;
}
```  
  
参考：  
https://oi-wiki.org/basic/enumerate/  
https://houbb.github.io/2020/01/23/data-struct-learn-07-base-enum  

