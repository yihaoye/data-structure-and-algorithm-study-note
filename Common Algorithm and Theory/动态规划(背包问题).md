## 背包问题题解（NP-Complete）
背包问题即遍历各种组合，因此第一直观思路是如 NQueen 问题般深度优先搜索（NQueen 解题属于深度优先搜索子类方法：递归回溯法）遍历所有组合，在此过程中找出满足限制条件的最优组合。  
  
但因为在此过程中其实会形成许多重复组合，因此可以使用动态规划进行降维是因为有很多 overlapping 子问题。如果没有重叠的子问题则无法使用动态规划。  
  

DP:  
```java
// Knapsack (NP-Complete)
// Question: given N items, w[i] is the weight of the i-th item, v[i] is the value of the i-th item, given a knapsack with capacity W. Maximize the total value, each item can be used 0 or 1 time.
public class Solution {
    // N items [(w,v),...] and W capacity, just mock here.
    int N, W;
    int[][] items = new int[N][2];

    public int Knapsack() { // main
        int res[] = new int[1];
        dfs(0, items[0][0], items[0][1], res);
        return res;
    }

    public void dfs(int index, int cur_w, int cur_v, int[] res) {
        res[0] = max(res[0], cur_v);
        if (index > N) return;
        for (int i=index; i < N; i++) {
            dfs(i+1, cur_w+items[i][0], cur_v+items[i][1], res);
        }
    }
}
```
  
时间复杂度 O(NW)，空间复杂度 O(NW) -> O(W)。  
只有在 W 比较小 (< 10^6) 且 n > 20 的情况下适合使用 DP。  
  
  
  


## DFS 、动态规划、回溯法、递归之间的关系是什么？
来源链接：https://www.zhihu.com/question/266403334/answer/308381354  
  
> 首先DFS叫做深度优先搜索，既然是搜索，必然会有个起点，也会有个终点。既然是深度优先，和BFS相比，DFS就是先一次性搜到底，再退一步，再走另一条路，再一次搜到底。想象一下你在迷宫，一个粗暴的方法就是把每条路径是试一遍。那么DFS过程中，你要退一步，就必然需要保存你走过每个点的所有信息，而且是又先后顺序的，符合后进先出的规则，那么就需要用一个栈，而递归过程中函数调用会自动产生栈帧，当你的栈的深度越来越大的时候，栈也越来越大，如果递归没有终止条件，就会爆栈了。而在退一步的过程中，你需要从当前状态回到之前的状态，那么这步操作就是回溯，回溯是递归的时候一定会产生的很自然的操作，只不过大部分情况下不需要回溯。如果你知道图，两个节点之间一条有向边连接，表示从这个点可以到那个点，那么你在DFS的过程中会产生一个图。动态规划是设置边界，然后从起点开始，从起点根据转移方程把能到达的状态全都算一遍，最终再去获得那个目标节点的状态。通常一个状态可能由多个状态到达，所以会有状态叠加。一般使用for循环写方便简洁。而如果使用记忆化搜索，在DFS的过程中记录状态，找到目标后，看看如果想知道目标状态，这个目标状态依赖什么状态，就是谁能到达它那里，然后再去算它依赖的状态，然后再去看依赖的状态，不断递归，最终回到起点，答案也就出来了。两者的基础都是整个状态图，可以说记忆化搜索和动态规划是一个东西，而DFS只是一种搜索方式。而DFS同样可以不用递归，自己模拟栈实现。  
  
总结：  
递归是DFS的一种实现方式，DFS是动态规划的一种实现方式。回溯法是DFS过程中可以进行的可选操作。  
回溯和动态规划放一起讨论。dfs和bfs放一起讨论。dfs相当于一种优化过的回溯算法。回溯算法就相当于暴力求解。动态规划就相当于减枝的回溯算法。  
  
