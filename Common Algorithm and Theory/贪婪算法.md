### 一. 什么是贪心算法？
贪心算法，又称贪婪算法(Greedy Algorithm)，是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优解出发来考虑，它所做出的仅是在某种意义上的局部最优解。  
贪婪算法是一种分阶段的工作，在每一个阶段，可以认为所做决定是最好的，而不考虑将来的后果。这种“眼下能够拿到的就拿”的策略是这类算法名称的来源。  
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。  
  
在解决最优解（或最优化）问题时，有以下 3 种方法：  
1. 贪心算法
2. 动态规划
3. 分枝界限法  
贪心算法与动态规划的不同在于，贪心算法对每个子问题的解决方案都做出选择、不能回退（目光短浅特性），动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。  
  
### 二、贪心算法的基本思路
1. 建立数学模型来描述问题。
2. 把求解的问题分成若干个子问题。
3. 对每一子问题求解，得到子问题的局部最优解。
4. 把子问题的解局部最优解合成原来解问题的一个解。
  
### 三、贪心算法适用的问题
贪心策略适用的前提是：局部最优策略能导致产生全局最优解。也就是当算法终止的时候，局部最优等于全局最优。简单的说，就是问题能分成子问题来解决，子问题的最优解能递推到最终问题的最优解，这种子问题最优解成为最优子结构。  
通常适合贪心算法的场景比较少，贪心算法不能解决的最优问题可以用动态规划解决或者可以结合、调整解决。  
  
### 四、贪心算法的实现框架
从问题的某一初始解出发；  
```java
while //（能朝给定总目标前进一步）
{
    // 利用可行的决策，求出可行解的一个解元素；  
}
// 由所有解元素组合成问题的一个可行解；  
```
又或如下模版(https://www.youtube.com/watch?v=ARvQcqJ_-NY):  
```java
// greedy should solve overview problem in stages, each stage pick up / consider one input from a given problem and if that input is feasible then include it in the solution, so by including all those feasible in inputs finally get an optimal solution.
GreedySolution (a, n) { // (int[] a, int n), a is input problem set and n is the size
    for (int i=0; i<n; i++) {
        x = select(a);
        if (feasible(x)) {
            solution += x;
        }
    }
}
```
  
### 五、贪心策略的选择
因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。  
如果确定可以使用贪心算法，那一定要选择合适的贪心策略；  
  
### 六、贪心算法的几个例子
  
1. 纸币找零问题
假设1元、2元、5元、10元、20元、50元、100元的纸币，张数不限制，现在要用来支付K元，至少要多少张纸币？  
很显然，我们很容易就想到使用贪心算法来解决，并且我们所根据的贪心策略是，每一步尽可能用面值大的纸币即可。当然这是正确的，代码如下：  
```java
/**
 * 钱币找零问题
 *
 * @param money the money
 */
public static void greedyGiveMoney(int money) {
    System.out.println("需要找零: " + money);
    int[] moneyLevel = {1, 5, 10, 20, 50, 100};
    for (int i = moneyLevel.length - 1; i >= 0; i--) {
        int num = money/ moneyLevel[i];
        int mod = money % moneyLevel[i];
        money = mod;
        if (num > 0) {
            System.out.println("需要" + num + "张" + moneyLevel[i] + "块的");
        }
    }
}
```
（1）如果不限制纸币的金额，那这种情况还适合用贪心算法么。比如1元，2元，3元，4元，8元，15元的纸币，用来支付K元，至少多少张纸币？  
经我们分析，这种情况是不适合用贪心算法的，因为我们上面提供的贪心策略不是最优解。比如，纸币1元，5元，6元，要支付10元的话，按照上面的算法，至少需要1张6元的，4张1元的，而实际上最优的应该是2张5元的。  
（2）如果限制纸币的张数，那这种情况还适合用贪心算法么。比如1元10张，2元20张，5元1张，用来支付K元，至少多少张纸币？  
同样，仔细想一下，就知道这种情况也是不适合用贪心算法的。比如1元10张，20元5张，50元1张，那用来支付60元，按照上面的算法，至少需要1张50元，10张1元，而实际上使用3张20元的即可；  
（3）所以贪心算法是一种在某种范围内，局部最优的算法。  
  
  
  
参考：  
https://www.cnblogs.com/xiaozhang2014/p/7783795.html  
https://blog.csdn.net/wang704987562/article/details/70991590  