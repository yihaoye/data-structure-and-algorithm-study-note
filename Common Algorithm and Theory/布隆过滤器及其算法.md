## 简介
布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量（位数组）和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。  
  
布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。  
  
优点：布隆过滤器存储空间和插入/查询时间都是常数 O(k)。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。  
缺点：随着存入的元素数量增加，误算率随之增加。  
  
## 使用场景
场景：判断一个元素是否存在一个集合中。  
诚然，该使用场景可以有多种数据结构（数组、链表、树、平衡二叉树、Trie、Map (红黑树)、哈希表等等）及算法配合（排序、二分搜索等等）来实现及优化，但是当集合里面的元素数量足够大，比如 500 万甚至 1 亿数量级时，常规的数据结构的问题就凸显出来了：数组、链表、树等数据结构会存储元素的内容，一旦数据量过大，消耗的内存也会呈现线性增长，最终达到瓶颈；而哈希表虽然效率很高 - 查询效率可以达到 O(1)，但是哈希表需要消耗的内存依然很高，使用哈希表存储一亿条垃圾邮件地址的过程是，首先，哈希函数将一个邮件地址映射成 8 字节信息指纹，考虑到哈希表存储效率通常小于 50%（哈希冲突），因此消耗的内存：8 * 2 * 1亿 字节 = 1.6G 内存，普通计算机是无法提供如此大的内存。  
这个时候，布隆过滤器（Bloom Filter）就应运而生。  
  
以上摘录自：https://www.cnblogs.com/cpselvis/p/6265825.html  
  
