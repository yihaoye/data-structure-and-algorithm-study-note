## 拓扑排序
  
有向图的拓扑排序是其顶点（节点）的线性排序，使得对于从顶点（节点） u 到顶点（节点）v 的每个有向边 uv，u 在排序中都在 v 之前。  
例如，图形的顶点（节点）可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。  
当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。  
任何有向无环图至少有一个拓扑排序。已知有算法可以在线性时间内，构建任何有向无环图的拓扑排序。  
在图论中，由一个有向无环图的顶点（节点）组成的序列，当且仅当满足下列条件时，才能称为该图的一个拓扑排序（英语：Topological sorting）：  
1. 序列中包含每个顶点（节点），且每个顶点（节点）只出现一次；
2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。  
  
拓扑排序有两种实现方式：卡恩算法、DFS。  
  
### 卡恩算法
简单来说，假设L是存放结果的列表，先找到那些入度为零的节点，把这些节点放到L中，因为这些节点没有任何的父节点。然后把与这些节点相连的边从图中去掉，再寻找图中的入度为零的节点。对于新找到的这些入度为零的节点来说，他们的父节点已经都在L中了，所以也可以放入L。重复上述操作，直到找不到入度为零的节点。如果此时L中的元素个数和节点总数相同，说明排序完成；如果L中的元素个数和节点总数不同，说明原图中存在环，无法进行拓扑排序。  
代码实现：(https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/)  
```java
// A Java program to print topological 
// sorting of a graph using indegrees 
import java.util.*; 
  
// Class to represent a graph 
class Graph { 
    // No. of vertices 
    int V; 
  
    // An Array of List which contains 
    // references to the Adjacency List of 
    // each vertex 
    List<Integer> adj[]; 
    // Constructor 
    public Graph(int V) { 
        this.V = V; 
        adj = new ArrayList[V]; 
        for (int i = 0; i < V; i++) 
            adj[i] = new ArrayList<Integer>(); 
    } 
  
    // Function to add an edge to graph 
    public void addEdge(int u, int v) { 
        adj[u].add(v); 
    } 
    // prints a Topological Sort of the 
    // complete graph 
    public void topologicalSort() { 
        // Create a array to store 
        // indegrees of all 
        // vertices. Initialize all 
        // indegrees as 0. 
        int indegree[] = new int[V]; 
  
        // Traverse adjacency lists 
        // to fill indegrees of 
        // vertices. This step takes 
        // O(V+E) time 
        for (int i = 0; i < V; i++) { 
            ArrayList<Integer> temp 
                = (ArrayList<Integer>)adj[i]; 
            for (int node : temp) { 
                indegree[node]++; 
            } 
        } 
  
        // Create a queue and enqueue 
        // all vertices with indegree 0 
        Queue<Integer> q 
            = new LinkedList<Integer>(); 
        for (int i = 0; i < V; i++) { 
            if (indegree[i] == 0) 
                q.add(i); 
        } 
  
        // Initialize count of visited vertices 
        int cnt = 0; 
  
        // Create a vector to store result 
        // (A topological ordering of the vertices) 
        Vector<Integer> topOrder = new Vector<Integer>(); 
        while (!q.isEmpty()) { 
            // Extract front of queue 
            // (or perform dequeue) 
            // and add it to topological order 
            int u = q.poll(); 
            topOrder.add(u); 
  
            // Iterate through all its 
            // neighbouring nodes 
            // of dequeued node u and 
            // decrease their in-degree 
            // by 1 
            for (int node : adj[u]) { 
                // If in-degree becomes zero, 
                // add it to queue 
                if (--indegree[node] == 0) 
                    q.add(node); 
            } 
            cnt++; 
        } 
  
        // Check if there was a cycle 
        if (cnt != V) { 
            System.out.println( 
                "There exists a cycle in the graph"); 
            return; 
        } 
  
        // Print topological order 
        for (int i : topOrder) 
            System.out.print(i + " "); 
    } 
} 
// Driver program to test above functions 
class Main { 
    public static void main(String args[]) { 
        // Create a graph given in the above diagram 
        Graph g = new Graph(6); 
        g.addEdge(5, 2); 
        g.addEdge(5, 0); 
        g.addEdge(4, 0); 
        g.addEdge(4, 1); 
        g.addEdge(2, 3); 
        g.addEdge(3, 1); 
        System.out.println("Following is a Topological Sort"); 
        g.topologicalSort(); 
    } 
} 
```
  
### DFS
  
![](./拓扑排序.png)  
![](./拓扑排序过程模拟.png)  
  
代码实现：  
```java
class Solution {    
    public List<Integer> TopoSort(int numCourses, int[][] prerequisites) {        
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
        ArrayList<Integer> sortedList = new ArrayList<>();
        
        for (int i = 0; i < numCourses; ++i)
            graph.add(new ArrayList<Integer>());
        
        for (int i = 0; i < prerequisites.length; ++i) {
            int course = prerequisites[i][0];
            int prerequisite = prerequisites[i][1];            
            graph.get(course).add(prerequisite);
        }
        
        // int[] visited -- states: 0 == unkonwn, 1 == visiting, 2 == visited
        int[] visited = new int[numCourses];
        for (int i = 0; i < numCourses; ++i)
            if (dfs(i, graph, visited, sortedList)) return new ArrayList<>(); // empty list means fail with circle
        
        return sortedList;
    }
    
    private boolean dfs(int curr, ArrayList<ArrayList<Integer>> graph, int[] visited, ArrayList<Integer> sortedList) {
        if (visited[curr] == 1) return true;
        if (visited[curr] == 2) return false;
        
        visited[curr] = 1;
                
        for (int next : graph.get(curr))
            if (dfs(next, graph, visited)) return true;
        
        if (visited[curr] != 2) sortedList.add(curr);
        visited[curr] = 2;
        return false;
    }
}
```
  
[相关题型](./../Leetcode%20Practices/algorithms/medium/207%20Course%20Schedule.java)  
  
参考：  
http://zxi.mytechroad.com/blog/graph/leetcode-207-course-schedule/  
https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F/  
https://oi-wiki.org/graph/topo/  
https://oi-wiki.org/graph/dag/  
