package com.commonsorts;

// 希尔排序 (时间复杂度：O(nlog2n)，不稳定，由计算机科学家希尔对直接插入排序的改良版，在此之前直接插入排序是最好的排序，即当时最好的算法的时间复杂度未突破O(n^2))

/*
对于直接插入排序问题，数据量巨大时。
1.将数的个数设为n，取奇数k=n/2，将下标差值为k的书分为一组，构成有序序列。
2.再取k=k/2 ，将下标差值为k的书分为一组，构成有序序列。
3.重复第二步，直到k=1执行简单插入排序。
*/

/*
如何写成代码：

1.首先确定分的组数。
2.然后对组中元素进行插入排序。
3.然后将length/2，重复1,2步，直到length=0为止。
*/


public class ShellSort {
    public void shellSort(int[] a){
        int d = a.length;
        while(d!=0) {
            d = d / 2;
            for (int x = 0; x < d; x++) { //分的组数

                //下面其实就是插入排序（参考文档里的C++的插入排序，完全一样）
                for (int i = x + d; i < a.length; i += d) { //组中的元素，从第二个数开始
                    int j = i - d; //j为有序序列最后一位的位数
                    int temp = a[i]; //要插入的元素
                    for (; j >= 0 && temp < a[j]; j -= d) { //从后往前遍历。
                        a[j + d] = a[j]; //向后移动d位
                    }
                    a[j + d] = temp;
                }

            }
        }
    }
}



//更详细解释：
/*
一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。
例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
然后我们对每列进行排序：
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
排序之后变为：
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
最后以1步长进行排序（此时就是简单的插入排序了）。



Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。
More： https://www.zhihu.com/question/28634804

// 大话数据结构：对顺序表L作希尔排序
void ShellSort(SqList *L)
{
	int i,j,k=0;
	int increment=L->length;
	do
	{
		increment=increment/3+1; // 增量序列
		for(i=increment+1;i<=L->length;i++)
		{
			if (L->r[i]<L->r[i-increment]) // 需将L->r[i]插入有序增量子表
			{
				L->r[0]=L->r[i]; // 暂存在L->r[0]
				for(j=i-increment;j>0 && L->r[0]<L->r[j];j-=increment)
					L->r[j+increment]=L->r[j]; // 记录后移，查找插入位置
				L->r[j+increment]=L->r[0]; // 插入
			}
		}
	}
	while(increment>1);
}
// “增量”的选取非常关键。我们在代码中第7行，是用increment=increment/3+1;的方式选取增量的，可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。不过大量的研究表明，当增量序列为dlta[k]=2t-k+1-1（0≤k≤t≤）时，可以获得不错的效率，其时间复杂度为O(n3/2)，要好于直接排序的O(n2)。需要注意的是，增量序列的最后一个增量值必须等于1才行。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。

讲解：https://www.jianshu.com/p/d730ae586cf3 图解部分简单易懂
*/


